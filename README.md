  Prototype Installation and Configuration
This system prototype was developed and deployed locally on a Windows machine using Docker to assist in managing multiple components efficiently. 

Stage 1: Installation of required Software and Dependencies
1.1)	 Docker Desktop was used to manage Thingsboard, PostgreSQL, and Eclipse Mosquitto. 
1.2)	 PostgreSQL was deployed via Docker as the backend database for Thingsboard to store data for the visualiser and Thingsboard system log. A separate volume was created on a host machine to store the forensic log generated by the SOC server.
1.3)	 Thingsboard was installed using official Thingsboard Docker images. It requires PostgreSQL and Java to run. 
1.4)	 Eclipse Mosquitto was installed using the official Mosquitto image. The configuration was modified to port 1884 to prevent collision with ThingsBoard’s MQTT broker, which runs on the default MQTT port 1883. 
1.5)	 Python 3.12 was used to develop the IoT simulator, SOC receiver, and Integrity Module. The libraries required to run this simulation were installed using the pip command, including:
-	paho-mqtt – MQTT communication
-	asyncpg, asyncio – for an efficient PostgreSQL interface with an asynchronous framework
-	tqdm – for progress bar

  Once all services have been installed and defined in the docker-compose.yml file, the system was launched using the command “docker compose up”. This will start all services, including Thingsboard, MQTT, PostgreSQL, and Mosquitto. The Thingsboard GUI can be accessed through a web browser at http://localhost:8080.
 
  Stage 2: Configuration
  
  2.1)	 PostgreSQL: A table for storing sensor readings was created with the name forensic_log, and has the following schema:
-	id SERIAL PRIMARY KEY,
-	hash TEXT,
-	raw_data TEXT,
-	generated_time TIMESTAMPTZ,
-	received_time TIMESTAMPTZ DEFAULT now(),
-	error TEXT DEFAULT NULL

 	2.2)	 Thingsboard: Default users (Sysadmin, Tenant, and Customer) were used for this system. Alert rules were configured for testing purposes, specifically temperature readings and inactivity alerts. Custom dashboard widgets were also set for a clear visualisation.
 	2.3)	 Mosquitto MQTT: A test user (test_access_device1) was added to Mosquitto using official documentation to create an account for publishing and subscribing on the specific topic.

 	Stage 3: Custom program development
 	All scripts were developed using the Python language due to its readability and extensive support for libraries. While Python was chosen for rapid prototyping, the script can be rewritten in a compiled language, such as C/C++, to improve performance.

 	3.1)	 IoT_simulator.py: The code simulates an IoT device. It is responsible for generating temperature, encrypting data, and transmitting it to the SOC Server. The script is written to run in a loop continuously after starting up and initial configuration, and can be stopped at any time, just like a real device.
-	Data Generation: The script generates a random 2-digit number between 22.0-28.0 to mimic the real device; the function occasionally injects anomaly values around 30-50 to simulate an anomaly pattern, which is of forensic interest. Each reading is timestamped at the moment of generation to prevent replay attacks and add value to the sensor data stored as evidence, then changes to the JSON dump payload format.
-	Data Encryption: The data generated is encrypted using AES-CBC by default to secure the data during the transition process. A 16-byte pre-shared key is used, and IV (Initial Vector) is random each time to further ensure ciphertext uniqueness and prevent pattern recognition. 
-	Data Transmission: The encrypted data is published with a unique topic over the MQTT protocol, which is the most common transportation protocol in IoT for its lightweight, easy implementations, and reliability.

  3.2)	 SOC_Server.py: The script is developed as an asynchronous program to efficiently manage concurrent tasks of receiving sensor data, storing forensic artefacts, and forwarding processed data to a visualisation platform. It also allows asyncpg, the most efficient library overall, to connect to PostgreSQL and supports scalability.
-	Data Reception: An MQTT subscriber client listens for messages from IoT_simulator.py on the same topic. 
-	Data Handling: The on_message() function is triggered every time a message arrives. It attempts to decrypt the payload, extracting the temperature and original timestamp, using the pre-shared key.
-	Data Storing: A SHA-256 hash value is computed from the original timestamp and raw encrypted payload.  For each message from an IoT device, data entry to the database includes a hash value, raw message, generated time, and time the database receives data to preserve the original and prove the integrity of the artefact. In case the raw data can’t be processed, the error message with the raw data and the received time are stored instead.
-	Data Forwarding: The processed data is reformatted into a hardcoded standard format and published to ThingsBoard’s MQTT broker via topic and device access token provided by the ThingsBoard platform.

 	3.3)	 Integrity_Checker.py: The standalone code developed for stored artefact verification
-	Data Querying: The program retrieves entries within the user-specific time range.
-	Data Validation: Each entry is decrypted to compute a new hash for comparison against the stored hash value. The script also calculates the amount of time between generation and storage.
-	Output Summary: A summary of the amount of valid data, hash mismatch, and entries with errors is generated, supporting forensic integrity.
